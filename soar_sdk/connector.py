import typing
from typing import Any, Optional

from pydantic import ValidationError

from phantom.action_result import ActionResult
from phantom.base_connector import BaseConnector

from .abstract import SOARClient

if typing.TYPE_CHECKING:
    from .actions_manager import ActionsManager


class AppConnector(SOARClient, BaseConnector):
    """
    The connector mainly generated by the App Wizard. It is extended to properly work
    with handlers provided by the app.

    Serves as the layer for exposing public BaseConnector API interface, so that App
    is no longer calling phantom library directly.

    In the future it should be replaced by another class accessing SOAR API.
    """

    def __init__(self, actions_manager: "ActionsManager"):

        # Call the BaseConnectors init first
        super().__init__()

        self.actions_manager = actions_manager

        self._state: dict = {}

    @classmethod
    def get_soar_base_url(cls) -> str:
        return cls._get_phantom_base_url()

    def set_csrf_info(self, token: str, referer: str) -> None:
        """Public method for setting the CSRF token in connector."""
        self._set_csrf_info(token, referer)

    def handle(
        self,
        input_data: str,
        handle: Optional[Any],
    ) -> str:
        """Public method for handling the input data with the selected handler"""
        self.print_progress_message = True
        return self._handle_action(input_data, handle)

    def handle_action(self, param):
        # Get the action that we are supposed to execute for this App Run
        action_id = self.get_action_identifier()

        self.debug_print("action_id", self.get_action_identifier())

        if handler := self.actions_manager.get_action(action_id):
            try:
                params = handler.meta.parameters.parse_obj(param)
            except ValidationError:
                # FIXME: Consider adding more details to this error, but be aware
                #  of possible PIIs.
                return False, f"Invalid input params for {action_id}"

            return handler(params)

        return False, f"Missing handler for action {action_id}"

    def initialize(self):
        # Load the state in initialize, use it to store data
        # that needs to be accessed across actions
        self._state = self.load_state() or {}

        # get the asset config
        # config = self.get_config()
        """
        # Access values in asset config by the name

        # Required values can be accessed directly
        required_config_name = config['required_config_name']

        # Optional values should use the .get() function
        optional_config_name = config.get('optional_config_name')
        """

        return True

    def finalize(self):
        self.save_state(self._state)
        return True

    def add_result(self, action_result: ActionResult):
        return self.add_action_result(action_result)

    def get_results(self):
        return self.get_action_results()

    def debug(
        self,
        tag: str,
        dump_object: typing.Union[str, list, dict, ActionResult, Exception] = "",
    ):
        self.debug_print(tag, dump_object)

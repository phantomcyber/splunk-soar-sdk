from typing import Any, TYPE_CHECKING, Union, Optional

from pydantic import ValidationError
import httpx

from soar_sdk.input_spec import InputSpecification
from soar_sdk.shims.phantom.action_result import ActionResult as PhantomActionResult
from soar_sdk.shims.phantom.base_connector import BaseConnector
from soar_sdk.exceptions import ActionFailure

from .abstract import SOARClient

if TYPE_CHECKING:
    from .actions_provider import ActionsProvider
import json


_INGEST_STATE_KEY = "ingestion_state"
_AUTH_STATE_KEY = "auth_state"
_CACHE_STATE_KEY = "asset_cache"


class AppConnector(BaseConnector, SOARClient):
    """
    The connector mainly generated by the App Wizard. It is extended to properly work
    with handlers provided by the app.

    Serves as the layer for exposing public BaseConnector API interface, so that App
    is no longer calling phantom library directly.

    In the future it should be replaced by another class accessing SOAR API.
    """

    def __init__(self, actions_provider: "ActionsProvider") -> None:
        # Call the BaseConnectors init first
        super().__init__()

        self.actions_provider = actions_provider
        self._client = httpx.Client(
            base_url=AppConnector.get_soar_base_url(),
            verify=False,  # noqa: S501
        )
        self.csrf_token = None
        self._artifacts = {}

        self.ingestion_state: dict = {}
        self.auth_state: dict = {}
        self.asset_cache: dict = {}

    @property
    def client(self) -> httpx.Client:
        return self._client

    def authenticate_soar_client(self, input_data: InputSpecification) -> None:
        session_id = input_data.user_session_token
        if session_id:
            self.__login()
        else:
            if all(
                env_var in input_data.environment_variables
                for env_var in ["PHANTOM_USER", "PHANTOM_PASSWORD", "PHANTOM_BASE_URL"]
            ):
                self._client = httpx.Client(
                    base_url=input_data.environment_variables["PHANTOM_BASE_URL"].value,
                    verify=False,  # noqa: S501
                )
                self.__login()
                print("hereeeee")
                session_id = self.get_session_id(
                    input_data.environment_variables["PHANTOM_USER"].value,
                    input_data.environment_variables["PHANTOM_PASSWORD"].value,
                )

        if session_id:
            current_cookies = self._client.headers.get("Cookie", "")
            update_cookies = f"sessionid={session_id};{current_cookies}"
            self._client.headers.update({"Cookie": update_cookies})

    def __login(self) -> None:
        response = self._client.get("/login")
        response.raise_for_status()
        self.csrf_token = response.cookies.get("csrftoken")
        self._client.cookies.update(response.cookies)
        self._client.headers.update({"X-CSRFToken": self.csrf_token})
        cookies = f"csrftoken={self.csrf_token}"
        self._client.headers.update({"Cookie": cookies})

    def get_session_id(self, username: str, password: str) -> str:
        self._client.post(
            "/login",
            data={
                "username": username,
                "password": password,
                "csrfmiddlewaretoken": self.csrf_token,
            },
            headers={"Referer": f"{self._client.base_url}/login"},
        )
        session_id = self._client.cookies.get("sessionid")
        return session_id

    def get(self, endpoint: str, **kwargs: dict) -> httpx.Response:
        """
        Perform a GET request to the specfic endpoint using the soar client
        """
        response = self._client.get(endpoint, **kwargs)
        response.raise_for_status()
        return response

    def post(self, endpoint: str, **kwargs: dict) -> httpx.Response:
        """
        Perform a GET request to the specfic endpoint using the soar client
        """
        headers = kwargs.pop("headers", {})
        headers.update({"Referer": f"{self._client.base_url}/{endpoint}"})

        response = self._client.post(endpoint, headers=headers, **kwargs)

        response.raise_for_status()
        return response

    def put(self, endpoint: str, **kwargs: dict) -> httpx.Response:
        """
        Perform a GET request to the specfic endpoint using the soar client
        """
        response = self._client.put(endpoint, **kwargs)
        response.raise_for_status()
        return response

    def _save_artifact(self, artifact: dict) -> tuple[bool, str, Optional[int]]:
        artifact.update(
            {k: v for k, v in self._artifact_common.items() if (not artifact.get(k))}
        )
        try:
            json.dumps(artifact)
        except TypeError as e:
            exception = getattr(e, "message", str(e))
            error_msg = f"json.dumps during Save artifact failed. Possibly a value in the artifact dictionary is not encoded properly. Exception: {exception}"
            self.error_print(error_msg)
            raise ActionFailure(error_msg) from e

        if self.csrf_token:
            try:
                response = self.post("rest/artifact", json=artifact)
            except Exception as e:
                error_msg = f"Failed to add artifact: {e}"
                raise ActionFailure(error_msg) from e

            resp_data = response.json()

            if "id" in resp_data:
                return (True, "Artifact added successfully", resp_data["id"])

            if "existing_artifact_id" in resp_data:
                return (
                    True,
                    "Artifact already exists",
                    resp_data["existing_artifact_id"],
                )

            msg_cause = resp_data.get("message", "NONE_GIVEN")
            message = f"artifact addition failed, reason from server: {msg_cause}"
            raise ActionFailure(message)

        else:
            if "container_id" not in artifact:
                message = "Artifact addition failed, no container ID given"
                raise ActionFailure(message)

            next_artifact_id = (
                max(self._artifacts.keys()) if self._artifacts else 0
            ) + 1
            self._artifacts[next_artifact_id] = artifact
            return (True, "Artifact added successfully", next_artifact_id)

    @classmethod
    def get_soar_base_url(cls) -> str:
        return cls._get_phantom_base_url()

    def set_csrf_info(self, token: str, referer: str) -> None:
        """Public method for setting the CSRF token in connector."""
        self._set_csrf_info(token, referer)

    def handle(
        self, input_data: InputSpecification, handle: Optional[int] = None
    ) -> str:
        """Public method for executing an action from a JSON string."""
        self.print_progress_message = True
        return self._handle_action(input_data.json(), handle or 0)

    def handle_action(self, param: dict[str, Any]) -> None:
        # Get the action that we are supposed to execute for this App Run
        action_id = self.get_action_identifier()
        self.debug_print("action_id", action_id)

        if handler := self.actions_provider.get_action(action_id):
            try:
                params = handler.meta.parameters.parse_obj(param)
            except (ValueError, ValidationError):
                # FIXME: Consider adding more details to this error, but be aware
                #  of possible PIIs.
                self.save_progress(
                    "Validation Error - the params data for action could not be parsed"
                )
                return

            handler(params)

        else:
            raise RuntimeError(f"Action {action_id} not found.")

    def initialize(self) -> bool:
        # Load the state in initialize, use it to store data
        # that needs to be accessed across actions
        state = self.load_state() or {}
        self.ingestion_state = state.get(_INGEST_STATE_KEY, {})
        self.auth_state = state.get(_AUTH_STATE_KEY, {})
        self.asset_cache = state.get(_CACHE_STATE_KEY, {})

        return True

    def finalize(self) -> bool:
        state = {
            _INGEST_STATE_KEY: self.ingestion_state,
            _AUTH_STATE_KEY: self.auth_state,
            _CACHE_STATE_KEY: self.asset_cache,
        }
        self.save_state(state)
        return True

    def add_result(self, action_result: PhantomActionResult) -> PhantomActionResult:
        return self.add_action_result(action_result)

    def get_results(self) -> list[PhantomActionResult]:
        return self.get_action_results()

    def debug(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.debug_print(tag, dump_object)

    def error(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.error_print(tag, dump_object)

    def add_exception(self, exception: Exception) -> None:
        self._BaseConnector__conn_result.add_exception(exception)
